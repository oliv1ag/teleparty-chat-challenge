import {
  __commonJS
} from "./chunk-BUSYA2B4.js";

// ../teleparty-websocket-lib/lib/SocketMessageTypes.js
var require_SocketMessageTypes = __commonJS({
  "../teleparty-websocket-lib/lib/SocketMessageTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SocketMessageTypes = void 0;
    var SocketMessageTypes;
    (function(SocketMessageTypes2) {
      SocketMessageTypes2["CREATE_SESSION"] = "createSession";
      SocketMessageTypes2["JOIN_SESSION"] = "joinSession";
      SocketMessageTypes2["SEND_MESSAGE"] = "sendMessage";
      SocketMessageTypes2["SET_TYPING_PRESENCE"] = "setTypingPresence";
    })(SocketMessageTypes = exports.SocketMessageTypes || (exports.SocketMessageTypes = {}));
  }
});

// ../teleparty-websocket-lib/lib/SocketCallbackManager.js
var require_SocketCallbackManager = __commonJS({
  "../teleparty-websocket-lib/lib/SocketCallbackManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SocketCallbackManager = void 0;
    var SocketCallbackManager = class {
      constructor() {
        this._callbackMap = /* @__PURE__ */ new Map();
      }
      makeId() {
        let result = "";
        const hexChars = "0123456789abcdef";
        for (let i = 0; i < 16; i += 1) {
          result += hexChars[Math.floor(Math.random() * 16)];
        }
        return result;
      }
      executeCallback(callbackId, data) {
        const callback = this._callbackMap.get(callbackId);
        if (callback) {
          callback(data);
          this._callbackMap.delete(callbackId);
        }
      }
      addCallback(callback) {
        let newId = this.makeId();
        while (this._callbackMap.has(newId)) {
          newId = this.makeId();
        }
        this._callbackMap.set(newId, callback);
        return newId;
      }
    };
    exports.SocketCallbackManager = SocketCallbackManager;
  }
});

// ../teleparty-websocket-lib/lib/TelepartyClient.js
var require_TelepartyClient = __commonJS({
  "../teleparty-websocket-lib/lib/TelepartyClient.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TelepartyClient = void 0;
    var SocketCallbackManager_1 = require_SocketCallbackManager();
    var SocketMessageTypes_1 = require_SocketMessageTypes();
    var SOCKET_URL = "wss://uwstest.teleparty.com";
    var MANUAL_CLOSE_CODE = 4500;
    var TelepartyClient = class {
      constructor(eventHandler) {
        this._socketEventHandler = eventHandler;
        this._socket = new WebSocket(SOCKET_URL);
        this._callbackManager = new SocketCallbackManager_1.SocketCallbackManager();
        this._handleSocketEvents();
        this._reconnectAttempts = 0;
      }
      _handleSocketEvents() {
        this._socket.onmessage = this._onMessage.bind(this);
        this._socket.onclose = this._onClose.bind(this);
        this._socket.onerror = this._onError.bind(this);
        this._socket.onopen = this._onOpen.bind(this);
      }
      _onMessage(event) {
        try {
          const message = JSON.parse(event.data);
          if (message.callbackId) {
            this._callbackManager.executeCallback(message.callbackId, message.data);
          } else {
            this._socketEventHandler.onMessage(message);
          }
        } catch (error) {
        }
      }
      _onOpen() {
        this._socketEventHandler.onConnectionReady();
      }
      _onClose(event) {
        this._socketEventHandler.onClose();
      }
      _onError(event) {
        this._socket.close();
      }
      _formatMessage(type, data, callbackId) {
        return {
          type,
          data,
          callbackId
        };
      }
      /**
       * Join a room with a given id
       * @param nickname The name of the user in chat
       * @param userIcon The users icon in chat (Optional)
       * @param roomId
       * @returns{MessageList} The list of previous messages in the session
       */
      joinChatRoom(nickname, roomId, userIcon) {
        return __awaiter(this, void 0, void 0, function* () {
          const joinData = {
            videoId: "0",
            sessionId: roomId,
            videoService: "netflix",
            permId: "0000000000000000",
            userSettings: {
              userIcon,
              userNickname: nickname
            }
          };
          const sessionData = yield new Promise((resolve) => {
            this.sendMessage(SocketMessageTypes_1.SocketMessageTypes.JOIN_SESSION, joinData, (res) => {
              resolve(res);
            });
          });
          if (sessionData.errorMessage) {
            throw new Error(sessionData.errorMessage);
          }
          return {
            messages: sessionData.messages
          };
        });
      }
      /**
       * Create a chat room
       * @param nickname The name of the user in chat
       * @param userIcon The users icon in chat (Optional)
       * @returns {string} The id for the created room
       */
      createChatRoom(nickname, userIcon) {
        return __awaiter(this, void 0, void 0, function* () {
          const createData = {
            controlLock: false,
            videoId: "0",
            videoDuration: 0,
            videoService: "netflix",
            permId: "0000000000000000",
            userSettings: {
              userIcon,
              userNickname: nickname
            }
          };
          const sessionData = yield new Promise((resolve) => {
            this.sendMessage(SocketMessageTypes_1.SocketMessageTypes.CREATE_SESSION, createData, (res) => {
              resolve(res);
            });
          });
          if (sessionData.errorMessage) {
            throw new Error(sessionData.errorMessage);
          }
          return sessionData.sessionId;
        });
      }
      /**
       * Send a message to the server over the Socket
       * @param type Type of message to send, see "SocketMessageTypes"
       * @param data
       * @param callback Optional Callback function, will return the response from the server
       */
      sendMessage(type, data, callback) {
        if (this._socket.readyState == 1) {
          let callbackId = "null";
          if (callback) {
            callbackId = this._callbackManager.addCallback(callback);
          }
          const socketMessage = this._formatMessage(type, data, callbackId);
          this._socket.send(JSON.stringify(socketMessage));
        } else {
          if (callback) {
            callback({
              errorMessage: "Connection isn't Ready yet."
            });
          }
        }
      }
      /**
       * Close the underlying websocket connectoin
       */
      teardown() {
        try {
          this._socket.close(MANUAL_CLOSE_CODE);
        } catch (e) {
        }
        if (this._reconnectTimeOut) {
          clearTimeout(this._reconnectTimeOut);
        }
        if (this._keepAliveInterval) {
          clearInterval(this._keepAliveInterval);
        }
      }
    };
    exports.TelepartyClient = TelepartyClient;
  }
});

// ../teleparty-websocket-lib/lib/index.js
var require_lib = __commonJS({
  "../teleparty-websocket-lib/lib/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TelepartyClient = exports.SocketMessageTypes = void 0;
    var SocketMessageTypes_1 = require_SocketMessageTypes();
    Object.defineProperty(exports, "SocketMessageTypes", { enumerable: true, get: function() {
      return SocketMessageTypes_1.SocketMessageTypes;
    } });
    var TelepartyClient_1 = require_TelepartyClient();
    Object.defineProperty(exports, "TelepartyClient", { enumerable: true, get: function() {
      return TelepartyClient_1.TelepartyClient;
    } });
  }
});
export default require_lib();
//# sourceMappingURL=teleparty-websocket-lib.js.map
